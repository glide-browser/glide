diff --git a/toolkit/components/extensions/ExtensionCommon.sys.mjs b/toolkit/components/extensions/ExtensionCommon.sys.mjs
index e4fe6aba74c6244ba506cf4b66f635d6450f639b..fe86e839ae913c4938e2d0384bfcc29e008481c0 100644
--- a/toolkit/components/extensions/ExtensionCommon.sys.mjs
+++ b/toolkit/components/extensions/ExtensionCommon.sys.mjs
@@ -691,6 +691,14 @@ export class BaseContext {
           Reflect.apply(callback, null, args)
         );
       } catch (e) {
+        if (this.extension.id === "glide-internal@mozilla.org") {
+          // store any errors that happen when invoking one of the listeners
+          // registered in the config so that the browser code can pick it up
+          // and report the error
+          this.$glide_errors ??= new Set();
+          this.$glide_errors.add({ error: e, source: "applySafeWithoutClone" });
+        }
+
         if (this.isProxyContextParent) {
           Cu.reportError(e);
         }
@@ -724,6 +732,10 @@ export class BaseContext {
   }
 
   checkLoadURL(url, options = {}) {
+    if (this.extension.id === "glide-internal@mozilla.org") {
+      return true;
+    }
+
     // As an optimization, f the URL starts with the extension's base URL,
     // don't do any further checks. It's always allowed to load it.
     if (url.startsWith(this.extension.baseURL)) {
@@ -2750,6 +2762,25 @@ class EventManager {
     EventManager._writePersistentListeners(extension);
   }
 
+  _callAndRecordGlideError(callback, thisArgument, args) {
+    try {
+      return Reflect.apply(callback, thisArgument, args);
+    } catch (error) {
+      if (this.context?.extension?.id === "glide-internal@mozilla.org") {
+        // store any errors that happen when invoking one of the listeners
+        // registered in the config so that the browser code can pick it up
+        // and report the error
+        this.context.$glide_errors ??= new Set();
+        this.context.$glide_errors.add({
+          error,
+          source: "_callAndRecordGlideError",
+        });
+      }
+
+      throw error;
+    }
+  }
+
   addListener(callback, ...args) {
     if (this.unregister.has(callback)) {
       return;
@@ -2809,12 +2840,12 @@ class EventManager {
           this.context.isProxyContextParent ||
           lazy.callFunctionAndLogExceptionDisabled
         ) {
-          result = Reflect.apply(callback, null, args);
+          result = this._callAndRecordGlideError(callback, null, args);
         } else {
           // Use callFunctionAndLogException in order to ensure routing any exception to DevTools.
           result = ChromeUtils.callFunctionAndLogException(
             this.context.cloneScope,
-            () => Reflect.apply(callback, null, args)
+            () => this._callAndRecordGlideError(callback, null, args)
           );
         }
         this.context.logActivity("api_event", this.name, { args, result });
